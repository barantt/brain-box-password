<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <title>è±å½¢æ£‹ç›˜ - å¯æ—‹è½¬å¸é™„çš„ L å½¢ç§¯æœ¨ï¼ˆKonvaï¼‰</title>
  <script src="https://unpkg.com/konva@9/konva.min.js"></script>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
    }

    body {
      background: #e9e9e9;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #container {
      width: 900px;
      height: 700px;
      background: #e9e9e9;
      border: 1px solid #bbb;
    }

    .instructions {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-size: 12px;
      color: #333;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <div class="instructions">
    <strong>æ“ä½œè¯´æ˜:</strong><br>
    â€¢ ç‚¹å‡»é€‰ä¸­ç§¯æœ¨<br>
    â€¢ æ‹–æ‹½æ—‹è½¬æ§åˆ¶å™¨æ—‹è½¬<br>
    â€¢ <strong>Hé”®</strong> æˆ– <strong>å·¦å³ç®­å¤´</strong>: æ°´å¹³ç¿»è½¬<br>
    â€¢ <strong>Vé”®</strong> æˆ– <strong>ä¸Šä¸‹ç®­å¤´</strong>: å‚ç›´ç¿»è½¬<br>
    â€¢ åŒå‡»é‡ç½®ç§¯æœ¨
  </div>

  <script>
    const width = 900;
    const height = 700;
    const halfBlockSize = 30;
    const center = { x: width / 2, y: height / 2 };

    // é‡åŠ›ç³»ç»Ÿé…ç½®
    const gravity = {
      force: 0.3,      // é‡åŠ›åŠ é€Ÿåº¦
      friction: 0.98,  // ç©ºæ°”é˜»åŠ›
      bounce: 5,     // åå¼¹ç³»æ•°
      groundY: height  // åœ°é¢ä½ç½®
    };

    function init() {
      let gridArr = []
      for (let i = -4; i <= 4; i++) {
        for (let j = 5; j >= -5; j--) {
          if (Math.abs(i % 2) === Math.abs(j % 2)) {
            continue
          }
          const x = i * halfBlockSize + center.x / 2;
          const y = j * halfBlockSize + center.y;
          gridArr.push([x, y])
        }
      }
      return gridArr;
    }

    const playgroundXY = init()

    // å­˜å‚¨æœ‰æ•ˆæ–¹æ ¼çš„ä¸­å¿ƒç‚¹ï¼ˆåœ¨initæ‰§è¡Œæ—¶è®°ä½ï¼‰
    const validGridCenters = playgroundXY.map(point => ({
      x: point[0],
      y: point[1]
    }));

    // ç»´æŠ¤æ ¼å­å ç”¨çŠ¶æ€ï¼Œé”®ä¸ºæ ¼å­åæ ‡å­—ç¬¦ä¸²ï¼Œå€¼ä¸ºå ç”¨çš„ç§¯æœ¨group
    const gridOccupancy = new Map();
    
    // åˆå§‹åŒ–æ‰€æœ‰æ ¼å­ä¸ºæœªå ç”¨çŠ¶æ€
    validGridCenters.forEach(grid => {
      const key = `${Math.round(grid.x)},${Math.round(grid.y)}`;
      gridOccupancy.set(key, null);
    });



    // æ ¼å­å ç”¨ç®¡ç†å‡½æ•°
    function getGridKey(x, y) {
      return `${Math.round(x)},${Math.round(y)}`;
    }
    
    function isGridOccupied(x, y, excludeGroup = null) {
      const key = getGridKey(x, y);
      const occupiedBy = gridOccupancy.get(key);
      return occupiedBy !== null && occupiedBy !== excludeGroup;
    }
    
    function occupyGrid(x, y, group) {
      const key = getGridKey(x, y);
      gridOccupancy.set(key, group);
    }
    
    function releaseGrid(x, y) {
      const key = getGridKey(x, y);
      gridOccupancy.set(key, null);
    }
    
    function releaseGroupGrids(group) {
      // é‡Šæ”¾è¯¥ç§¯æœ¨å ç”¨çš„æ‰€æœ‰æ ¼å­
      for (const [key, occupiedBy] of gridOccupancy.entries()) {
        if (occupiedBy === group) {
          gridOccupancy.set(key, null);
        }
      }
    }
    
    // æ£€æŸ¥æ‹¼å›¾æ˜¯å¦å®Œæˆ
    function checkPuzzleCompletion() {
      // è®¡ç®—è¢«å ç”¨çš„æ ¼å­æ•°é‡
      let occupiedCount = 0;
      for (const [key, occupiedBy] of gridOccupancy.entries()) {
        if (occupiedBy !== null) {
          occupiedCount++;
        }
      }
      
      // å¦‚æœæ‰€æœ‰æ ¼å­éƒ½è¢«å ç”¨ï¼Œåˆ™æ‹¼å›¾å®Œæˆ
      if (occupiedCount === validGridCenters.length) {
        showCompletionMessage();
        return true;
      }
      
      return false;
    }
    
    // æ˜¾ç¤ºå®Œæˆåº†ç¥ä¿¡æ¯
    function showCompletionMessage() {
      // åˆ›å»ºåº†ç¥æ–‡æœ¬
      const completionText = new Konva.Text({
        x: width / 2 - 100,
        y: height / 2 - 50,
        text: 'ğŸ‰ æ­å–œï¼æ‹¼å›¾å®Œæˆï¼ ğŸ‰',
        fontSize: 24,
        fontFamily: 'Arial',
        fill: '#ff6b6b',
        stroke: '#ffffff',
        strokeWidth: 2,
        align: 'center',
        width: 200
      });
      
      // åˆ›å»ºèƒŒæ™¯çŸ©å½¢
      const completionBg = new Konva.Rect({
        x: width / 2 - 120,
        y: height / 2 - 70,
        width: 240,
        height: 100,
        fill: 'rgba(255, 255, 255, 0.95)',
        stroke: '#ff6b6b',
        strokeWidth: 3,
        cornerRadius: 10,
        shadowColor: 'black',
        shadowBlur: 10,
        shadowOpacity: 0.3
      });
      
      // åˆ›å»ºåº†ç¥ç»„
      const celebrationGroup = new Konva.Group({
        name: 'celebration'
      });
      
      celebrationGroup.add(completionBg);
      celebrationGroup.add(completionText);
      
      // æ·»åŠ é—ªçƒåŠ¨ç”»
      const tween = new Konva.Tween({
        node: celebrationGroup,
        duration: 0.8,
        opacity: 0.3,
        yoyo: true,
        repeat: -1 // æ— é™é‡å¤
      });
      
      layer.add(celebrationGroup);
      layer.draw();
      tween.play();
      
      // 5ç§’åè‡ªåŠ¨éšè—åº†ç¥ä¿¡æ¯
      setTimeout(() => {
        tween.destroy();
        celebrationGroup.destroy();
        layer.draw();
      }, 5000);
    }


    // æ ¹æ®åƒç´ ç‚¹æ‰¾åˆ°æœ€è¿‘çš„æ ¼å­ï¼Œå¹¶è€ƒè™‘è±å½¢åŒºåŸŸ
    function findNearestGrid(x, y, maxDist) {
      let best = null;
      let bestD = Infinity;

      for (const g of validGridCenters) {
        // è®¡ç®—åˆ°æ ¼å­ä¸­å¿ƒçš„è·ç¦»
        const dx = g.x - x;
        const dy = g.y - y;
        const d = Math.hypot(dx, dy);

        if (d < bestD && d <= maxDist) {
          bestD = d;
          best = g;
        }
      }

      return best;
    }

    function snapToGrid(group) {
      // è·å–ç§¯æœ¨ç»„ä¸­çš„ç¬¬ä¸€ä¸ªæ–¹å—ä½œä¸ºåŸºå‡†
      const firstBlock = group.getChildren()[0];
      if (!firstBlock) return false;

      // è·å–æ–¹å—çš„å°ºå¯¸
      const blockSize = Math.hypot(halfBlockSize, halfBlockSize);

      // è®¡ç®—ç¬¬ä¸€ä¸ªæ–¹å—ç›¸å¯¹äºgroupçš„æœ¬åœ°ä¸­å¿ƒåæ ‡
      const blockLocalCenterX = firstBlock.x() + blockSize / 2;
      const blockLocalCenterY = firstBlock.y() + blockSize / 2;

      // å°†æ–¹å—çš„æœ¬åœ°ä¸­å¿ƒåæ ‡è½¬æ¢ä¸ºä¸–ç•Œåæ ‡
      const groupTransform = group.getTransform();
      const rotatedPoint = groupTransform.point({
        x: blockLocalCenterX,
        y: blockLocalCenterY
      });

      const nearestGrid = findNearestGrid(rotatedPoint.x, rotatedPoint.y, halfBlockSize * 3);

      if (nearestGrid) {
        const currentBlockCenterX = rotatedPoint.x;
        const currentBlockCenterY = rotatedPoint.y;

        const offsetX = nearestGrid.x - currentBlockCenterX;
        const offsetY = nearestGrid.y - currentBlockCenterY;

        // æ£€æŸ¥å¸é™„åç§¯æœ¨çš„æ¯ä¸ªæ–¹å—ä¸­å¿ƒæ˜¯å¦éƒ½å¯¹åº”åˆ°æ£‹ç›˜çš„æœ‰æ•ˆæ ¼å­ä¸­å¿ƒç‚¹
        const allBlocksOnValidGrids = group.getChildren().every(block => {
          const blockLocalCenterX = block.x() + blockSize / 2;
          const blockLocalCenterY = block.y() + blockSize / 2;
          
          // è®¡ç®—å¸é™„åè¯¥æ–¹å—çš„ä¸–ç•Œåæ ‡
          const futureGroupX = group.x() + offsetX;
          const futureGroupY = group.y() + offsetY;
          
          const futureTransform = new Konva.Transform();
          futureTransform.translate(futureGroupX, futureGroupY);
          futureTransform.rotate(group.rotation() * Math.PI / 180);
          futureTransform.scale(group.scaleX(), group.scaleY());
          
          const futureBlockCenter = futureTransform.point({
            x: blockLocalCenterX,
            y: blockLocalCenterY
          });
          
          // æ£€æŸ¥è¯¥æ–¹å—ä¸­å¿ƒæ˜¯å¦åœ¨æŸä¸ªæœ‰æ•ˆæ ¼å­ä¸­å¿ƒä¸Šï¼ˆå…è®¸å°è¯¯å·®ï¼‰
          const tolerance = 5; // å®¹é”™èŒƒå›´
          let targetGrid = null;
          
          const isOnValidGrid = validGridCenters.some(gridCenter => {
            const distance = Math.hypot(
              futureBlockCenter.x - gridCenter.x,
              futureBlockCenter.y - gridCenter.y
            );
            if (distance <= tolerance) {
              targetGrid = gridCenter;
              return true;
            }
            return false;
          });
          
          if (!isOnValidGrid) {
            return false;
          }
          
          // æ£€æŸ¥ç›®æ ‡æ ¼å­æ˜¯å¦è¢«å…¶ä»–ç§¯æœ¨å ç”¨ï¼ˆæ’é™¤å½“å‰ç§¯æœ¨ï¼‰
          if (isGridOccupied(targetGrid.x, targetGrid.y, group)) {
            return false;
          }
          
          return true;
        });

        if (!allBlocksOnValidGrids) {
          return false;
        }
        
        // å…ˆé‡Šæ”¾è¯¥ç§¯æœ¨ä¹‹å‰å ç”¨çš„æ ¼å­ï¼ˆå¦‚æœæœ‰ï¼‰
        releaseGroupGrids(group);
        
        // æ‰€æœ‰æ–¹å—éƒ½åœ¨æœ‰æ•ˆæ ¼å­ä¸Šä¸”æœªè¢«å ç”¨ï¼Œæ‰§è¡Œå¸é™„
        group.x(group.x() + offsetX);
        group.y(group.y() + offsetY);
        
        // æ ‡è®°æ–°çš„æ ¼å­ä¸ºå·²å ç”¨
        group.getChildren().forEach(block => {
          const blockLocalCenterX = block.x() + blockSize / 2;
          const blockLocalCenterY = block.y() + blockSize / 2;
          
          const currentTransform = group.getTransform();
          const blockWorldPos = currentTransform.point({
            x: blockLocalCenterX,
            y: blockLocalCenterY
          });
          
          // æ‰¾åˆ°æœ€è¿‘çš„æ ¼å­å¹¶æ ‡è®°ä¸ºå·²å ç”¨
          const targetGrid = validGridCenters.find(gridCenter => {
            const distance = Math.hypot(
              blockWorldPos.x - gridCenter.x,
              blockWorldPos.y - gridCenter.y
            );
            return distance <= 5;
          });
          
          if (targetGrid) {
            occupyGrid(targetGrid.x, targetGrid.y, group);
          }
        });
        
        // é”å®šä¸ºå·²å¸é™„ï¼ˆåœæ­¢é‡åŠ›ï¼‰
        group.physics.isGrounded = true;
        group.physics.velocityY = 0;
        
        // æ£€æŸ¥æ‹¼å›¾æ˜¯å¦å®Œæˆ
        checkPuzzleCompletion();
        
        return true;
      }

      return false;
    }


    function singleBlock(x, y, color) {
      const rect = new Konva.Line({
        points: [
          x, y + halfBlockSize,
          x + halfBlockSize, y,
          x, y - halfBlockSize,
          x - halfBlockSize, y
        ],
        fill: color,
        stroke: 'black',
        strokeWidth: 1,
        closed: true,
      });
      return rect;
    }

    const stage = new Konva.Stage({
      container: 'container',
      width: width,
      height: height,
    });

    const layer = new Konva.Layer();

    // æ£‹ç›˜ç»„
    const group1 = new Konva.Group({
      x: 0,
      y: 0,
      width: width / 2,
      height: height,
      name: 'yellow'
    });

    const playground = new Konva.Rect({
      width: width / 2,
      height: height,
      fill: 'yellow',
      stroke: 'black',
      strokeWidth: 1,
    });
    group1.add(playground);

    playgroundXY.forEach(item => {
      const rect = singleBlock(item[0], item[1], 'white')
      group1.add(rect);
    })


    // ç§¯æœ¨ç»„
    const group2 = new Konva.Group({
      x: 0,
      y: 0,
      width: width / 2,
      height: height,
      name: 'green'
    });

    // å®šä¹‰Lå½¢ç§¯æœ¨çš„å½¢çŠ¶æ•°æ®å’Œé¢œè‰² (4ä¸ªä¸åŒçš„Lå½¢ç§¯æœ¨)
    const lShapes = [
      // Lå½¢ç§¯æœ¨1
      {
        shape: [
          [1, 0, 0],
          [1, 0, 0],
          [1, 0, 0],
          [1, 0, 0]
        ],
        color: {
          fill: '#572765',      // çº¢è‰²
          stroke: '#572765'     // æ·±çº¢è‰²è¾¹æ¡†
        }
      },
      {
        shape: [
          [1, 0, 0],
          [1, 0, 0],
          [1, 0, 0],
          [1, 1, 0],
        ],
        color: {
          fill: '#193376',      // é’è‰²
          stroke: '#193376'     // æ·±é’è‰²è¾¹æ¡†
        }
      },
      {
        shape: [
          [1, 0, 0],
          [1, 1, 0],
          [1, 1, 0],
          [0, 0, 0],
        ],
        color: {
          fill: '#e4132e',      // é’è‰²
          stroke: '#e4132e'     // æ·±é’è‰²è¾¹æ¡†
        }
      },
      {
        shape: [
          [1, 0, 0],
          [1, 1, 0],
          [0, 1, 0],
          [0, 1, 0],
        ],
        color: {
          fill: '#058434',      // é’è‰²
          stroke: '#058434'     // æ·±é’è‰²è¾¹æ¡†
        }
      },
      {
        shape: [
          [0, 0, 0],
          [0, 0, 1],
          [0, 1, 1],
          [1, 1, 0],
        ],
        color: {
          fill: '#dc506e',      // é’è‰²
          stroke: '#dc506e'     // æ·±é’è‰²è¾¹æ¡†
        }
      },
      {
        shape: [
          [1, 1, 1],
          [0, 0, 1],
          [0, 0, 1],
          [0, 0, 0],
        ],
        color: {
          fill: '#9dc9ba',      // é’è‰²
          stroke: '#9dc9ba'     // æ·±é’è‰²è¾¹æ¡†
        }
      },
      {
        shape: [
          [1, 0, 0],
          [1, 1, 0],
          [0, 1, 0],
          [0, 0, 0],
        ],
        color: {
          fill: '#85381c',      // é’è‰²
          stroke: '#85381c'     // æ·±é’è‰²è¾¹æ¡†
        }
      },
      {
        shape: [
          [0, 0, 0],
          [0, 1, 1],
          [0, 0, 1],
          [0, 1, 1],
        ],
        color: {
          fill: '#dbb301',      // é’è‰²
          stroke: '#dbb301'     // æ·±é’è‰²è¾¹æ¡†
        }
      },
      {
        shape: [
          [1, 0, 0],
          [1, 0, 0],
          [1, 1, 0],
          [0, 0, 0],
        ],
        color: {
          fill: '#fe200c',      // é’è‰²
          stroke: '#fe200c'     // æ·±é’è‰²è¾¹æ¡†
        }
      },
      {
        shape: [
          [1, 0, 0],
          [1, 0, 0],
          [1, 1, 0],
          [1, 0, 0],
        ],
        color: {
          fill: '#dfbca8',      // é’è‰²
          stroke: '#dfbca8'     // æ·±é’è‰²è¾¹æ¡†
        }
      },
      {
        shape: [
          [1, 0, 0],
          [1, 1, 0],
          [1, 0, 0],
          [0, 0, 0],
        ],
        color: {
          fill: '#9daf26',
          stroke: '#9daf26'
        }
      },
      {
        shape: [
          [1, 0, 0],
          [1, 1, 0],
          [0, 0, 0],
          [0, 0, 0],
        ],
        color: {
          fill: '#cfc2a4',      // é’è‰²
          stroke: '#cfc2a4'     // æ·±é’è‰²è¾¹æ¡†
        }
      }
    ];

    let transformerNodes = []

    // ç§¯æœ¨ç¿»è½¬å‡½æ•°
    function flipBlock(group, direction) {
      if (direction === 'horizontal') {
        // æ°´å¹³ç¿»è½¬
        group.physics.isFlippedX = !group.physics.isFlippedX;
        const scaleX = group.physics.isFlippedX ? -1 : 1;
        group.scaleX(scaleX);
      } else if (direction === 'vertical') {
        // å‚ç›´ç¿»è½¬
        group.physics.isFlippedY = !group.physics.isFlippedY;
        const scaleY = group.physics.isFlippedY ? -1 : 1;
        group.scaleY(scaleY);
      }
      layer.draw();
    }

    // è·å–å½“å‰é€‰ä¸­çš„ç§¯æœ¨
    function getSelectedBlock() {
      return transformerNodes.find(node => node.physics.isSelected);
    }

    // åˆ›å»ºæ‰€æœ‰Lå½¢ç§¯æœ¨ï¼Œä¸ºæ¯ä¸ªç§¯æœ¨è®¾ç½®ä¸åŒçš„åˆå§‹ä½ç½®
    for (let shapeIndex = 0; shapeIndex < lShapes.length; shapeIndex++) {
      const shapeConfig = lShapes[shapeIndex];  // è·å–ç§¯æœ¨é…ç½®
      const shapeData = shapeConfig.shape;      // è·å–å½¢çŠ¶æ•°æ®
      const shapeColor = shapeConfig.color;     // è·å–é¢œè‰²é…ç½®

      // ä¸ºæ¯ä¸ªç§¯æœ¨è®¾ç½®ä¸åŒçš„åˆå§‹ä½ç½®ï¼Œé¿å…é‡å 
      const baseX = width / 2; // åœ¨å³ä¾§åŒºåŸŸçš„å›ºå®šèµ·å§‹ä½ç½®
      const baseY = shapeIndex * 120; // å‚ç›´æ’åˆ—ï¼Œæ¯ä¸ªç§¯æœ¨é—´éš”120åƒç´ 

      const tmpGroup = new Konva.Group({
        x: baseX + 150,
        y: baseY + 50,
        draggable: true,
        rotation: 45
      });

      // æ ¹æ®äºŒç»´æ•°ç»„æ¸²æŸ“å°æ–¹å—
      for (let row = 0; row < 4; row++) {
        for (let col = 0; col < 3; col++) {
          if (shapeData[row] && shapeData[row][col] === 1) {
            const blockSize = Math.hypot(halfBlockSize, halfBlockSize);
            const block = new Konva.Rect({
              x: col * blockSize,  // ç›¸å¯¹äºtmpGroupçš„åæ ‡
              y: row * blockSize,  // ç›¸å¯¹äºtmpGroupçš„åæ ‡
              width: blockSize,
              height: blockSize,
              fill: shapeColor.fill,        // ä½¿ç”¨è‡ªå®šä¹‰å¡«å……é¢œè‰²
              stroke: shapeColor.stroke,              // å¢åŠ è¾¹æ¡†å®½åº¦è®©é¢œè‰²æ›´æ˜æ˜¾
            });
            tmpGroup.add(block);
          }
        }
      }

      // ä¸ºæ¯ä¸ªç§¯æœ¨æ·»åŠ ç‰©ç†å±æ€§
      tmpGroup.physics = {
        velocityY: 0,      // Yè½´é€Ÿåº¦
        isGrounded: false, // æ˜¯å¦åœ¨åœ°é¢ä¸Š
        isDragging: false, // æ˜¯å¦æ­£åœ¨è¢«æ‹–æ‹½
        isSelected: false, // æ˜¯å¦è¢«é€‰ä¸­
        isFlippedX: false, // æ˜¯å¦æ°´å¹³ç¿»è½¬
        isFlippedY: false  // æ˜¯å¦å‚ç›´ç¿»è½¬
      };

      transformerNodes.push(tmpGroup)
      group2.add(tmpGroup);
    }

    // åˆ›å»ºä¸€ä¸ªç©ºçš„Transformerï¼Œç¨ååŠ¨æ€ç»‘å®šåˆ°è¢«é€‰ä¸­çš„ç§¯æœ¨
    const tr = new Konva.Transformer({
      rotationSnaps: [0, 45, 135, 225, 315],
      rotationSnapTolerance: 45,
      enabledAnchors: [],
      resizeEnabled: false,
      borderEnabled: false,
    });

    // ä¸ºæ¯ä¸ªtmpGroupæ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬ï¼Œå®ç°å•ç‹¬é€‰æ‹©
    transformerNodes.forEach(tmpGroup => {
      tmpGroup.on('click', function () {
        transformerNodes.forEach(node => node.physics.isSelected = false);
        this.physics.isSelected = true;
        this.physics.velocityY = 0;
        tr.nodes([tmpGroup]);
        layer.draw();
      });

      tmpGroup.on('dblclick', function () {
        // é‡æ–°ä»é¡¶éƒ¨å¼€å§‹æ‰è½
        releaseGroupGrids(this); // é‡Šæ”¾å ç”¨çš„æ ¼å­
        this.y(50);
        this.physics.velocityY = 0;
        this.physics.isGrounded = false;  // é‡ç½®ä¸ºæœªè½åœ°ï¼Œé‡æ–°å¯ç”¨é‡åŠ›
        this.physics.isSelected = false;
        tr.nodes([]);
        
        // éšè—å¯èƒ½å­˜åœ¨çš„åº†ç¥ä¿¡æ¯
        const celebrationGroup = layer.findOne('.celebration');
        if (celebrationGroup) {
          celebrationGroup.destroy();
        }
        
        layer.draw();
      });

      tmpGroup.on('dragstart', function () {
        this.physics.isDragging = true;
        // å¼€å§‹æ‹–æ‹½æ—¶é‡Šæ”¾è¯¥ç§¯æœ¨å ç”¨çš„æ‰€æœ‰æ ¼å­
        releaseGroupGrids(this);
        this.physics.isGrounded = false; // é‡æ–°å¯ç”¨é‡åŠ›ï¼ˆå¦‚æœæœªå¸é™„æˆåŠŸï¼‰
        this.opacity(0.9);
      });

      tmpGroup.on('dragend', function () {
        this.physics.isDragging = false;

        // ç”¨æ–°çš„å¸é™„å‡½æ•°å°è¯•å¸é™„
        const snapped = snapToGrid(this);

        // è‹¥æœªå¸é™„æˆåŠŸä¸”ä¹‹å‰æ²¡æœ‰è½åœ°ï¼Œæ‰é‡æ–°å¯ç”¨é‡åŠ›
        if (!snapped && !this.physics.isGrounded) {
          // åªæœ‰ä»æœªè½åœ°çš„ç§¯æœ¨æ‰ä¼šé‡æ–°å¼€å§‹ä¸‹è½
          // è¿™é‡Œä¸éœ€è¦è®¾ç½® isGrounded = falseï¼Œå› ä¸ºå®ƒæœ¬æ¥å°±æ˜¯ false
        }

        this.opacity(1);
        layer.draw();
      });
    });

    // é‡åŠ›ç³»ç»Ÿæ›´æ–°å‡½æ•°
    function updatePhysics() {
      transformerNodes.forEach(tmpGroup => {
        const physics = tmpGroup.physics;

        // è¢«æ‹–æ‹½ã€è¢«é€‰ä¸­æˆ–å·²è½åœ°çš„ç§¯æœ¨ï¼Œä¸åº”ç”¨é‡åŠ›
        if (physics.isDragging || physics.isSelected || physics.isGrounded) {
          return; // forEach çš„ return ç»§ç»­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        }

        // è·å–ç»å¯¹åŒ…å›´ç›’æ¥åˆ¤æ–­åº•éƒ¨ï¼ˆè€ƒè™‘æ—‹è½¬ï¼‰
        const box = tmpGroup.getClientRect();
        const bottom = box.y + box.height;

        // å¦‚æœå·²ç»æ’åˆ°åœ°é¢
        if (bottom >= gravity.groundY) {
          // æŠŠ group è°ƒæ•´åˆ°åœ°é¢ä½ç½®
          const delta = gravity.groundY - bottom; // é€šå¸¸ä¸º <= 0
          tmpGroup.y(tmpGroup.y() + delta);
          
          // æ°¸ä¹…è®¾ç½®ä¸ºå·²è½åœ°ï¼Œä¸å†å—é‡åŠ›å½±å“
          physics.isGrounded = true;
          physics.velocityY = 0;
        } else {
          // åœ¨ç©ºä¸­ï¼Œåº”ç”¨é‡åŠ›
          physics.velocityY += gravity.force;
          physics.velocityY *= gravity.friction;

          // å°†é€Ÿåº¦ç›´æ¥ä½œä¸ºå±€éƒ¨ y çš„å¢é‡ï¼ˆçˆ¶å®¹å™¨æ— æ—‹è½¬æ—¶æˆç«‹ï¼‰
          tmpGroup.y(tmpGroup.y() + physics.velocityY);
        }
      });

      layer.draw();
    }

    // å¯åŠ¨é‡åŠ›ç³»ç»Ÿ
    const anim = new Konva.Animation(updatePhysics, layer);
    anim.start();

    // ç‚¹å‡»ç©ºç™½åŒºåŸŸå–æ¶ˆé€‰æ‹©
    stage.on('click', function (e) {
      // å¦‚æœç‚¹å‡»çš„ä¸æ˜¯ç§¯æœ¨ï¼Œåˆ™å–æ¶ˆTransformerçš„é€‰æ‹©
      if (e.target === stage || e.target.getParent() === group1 || e.target.getParent() === group2) {
        // å–æ¶ˆæ‰€æœ‰ç§¯æœ¨çš„é€‰ä¸­çŠ¶æ€ï¼Œæ¢å¤é‡åŠ›
        transformerNodes.forEach(node => {
          node.physics.isSelected = false;
        });

        tr.nodes([]);
        layer.draw();
      }
    });

    // æ·»åŠ é”®ç›˜äº‹ä»¶ç›‘å¬å™¨å¤„ç†ç¿»è½¬æ“ä½œ
    window.addEventListener('keydown', function(e) {
      const selectedBlock = getSelectedBlock();
      if (!selectedBlock) return; // æ²¡æœ‰é€‰ä¸­çš„ç§¯æœ¨
      
      switch(e.key.toLowerCase()) {
        case 'h': // Hé”® - æ°´å¹³ç¿»è½¬
        case 'arrowleft': // å·¦ç®­å¤´ - æ°´å¹³ç¿»è½¬
        case 'arrowright': // å³ç®­å¤´ - æ°´å¹³ç¿»è½¬
          e.preventDefault();
          flipBlock(selectedBlock, 'horizontal');
          break;
        case 'v': // Vé”® - å‚ç›´ç¿»è½¬
        case 'arrowup': // ä¸Šç®­å¤´ - å‚ç›´ç¿»è½¬
        case 'arrowdown': // ä¸‹ç®­å¤´ - å‚ç›´ç¿»è½¬
          e.preventDefault();
          flipBlock(selectedBlock, 'vertical');
          break;
      }
    });


    layer.add(group1);
    layer.add(group2)
    layer.add(tr);
    stage.add(layer);
  </script>
</body>

</html>